import React, { useEffect } from 'react';
import GraphinContext from '../GraphinContext';

var DragNodeWithForce = function DragNodeWithForce(props) {
  var _React$useContext = React.useContext(GraphinContext),
      graph = _React$useContext.graph,
      layout = _React$useContext.layout,
      dragNodes = _React$useContext.dragNodes,
      updateContext = _React$useContext.updateContext;

  var autoPin = props.autoPin,
      pinAction = props.pinAction,
      _props$dragNodeMass = props.dragNodeMass,
      dragNodeMass = _props$dragNodeMass === void 0 ? 10000000000 : _props$dragNodeMass;
  var instance = layout.instance;
  useEffect(function () {
    var _a;

    var _ref = instance || {
      type: (_a = graph.get('layout')) === null || _a === void 0 ? void 0 : _a.type
    },
        simulation = _ref.simulation,
        type = _ref.type;

    var handleNodeDragStart = function handleNodeDragStart() {
      var _a;

      if (simulation) {
        simulation.stop();
      } else {
        var layouts = ((_a = graph.get('layoutController')) === null || _a === void 0 ? void 0 : _a.layoutMethods) || []; // @ts-ignore

        layouts.forEach(function (layout) {
          var _a;

          return (_a = layout.stop) === null || _a === void 0 ? void 0 : _a.call(layout);
        });
      }
    };

    var handleNodeDragEnd = function handleNodeDragEnd(e) {
      if (type !== 'graphin-force' && type !== 'force2') {
        return;
      }

      if (e.item) {
        var nodeModel = e.item.get('model');
        nodeModel.layout = Object.assign(Object.assign({}, nodeModel.layout), {
          force: {
            mass: autoPin ? dragNodeMass : null
          }
        }); // simulation.restart([nodeModel], graph);
        // graph.refreshPositions();

        var selectedNodes = [];
        graph.getNodes().forEach(function (node) {
          if (node.hasState('selected')) {
            var selectNodeModel = node.get('model');
            if (!selectNodeModel.layout) selectNodeModel.layout = {};
            selectNodeModel.layout.force = {
              mass: autoPin ? dragNodeMass : null
            };
            selectedNodes.push(selectNodeModel);
          }
        });
        var newDragNodes = dragNodes.concat([nodeModel]); // 多选拖动的场景

        if (selectedNodes.length > 1) {
          newDragNodes = newDragNodes.concat(selectedNodes);
        }

        updateContext({
          dragNodes: newDragNodes
        });
      }
    };

    graph.on('node:dragstart', handleNodeDragStart);
    graph.on('node:dragend', handleNodeDragEnd);
    return function () {
      graph.off('node:dragstart', handleNodeDragStart);
      graph.off('node:dragend', handleNodeDragEnd);
    };
  }, [graph, autoPin, instance, dragNodes, updateContext]);
  /** props 控制一个 pin 的动作，可能是 pin 或 unpin */

  useEffect(function () {
    var _ref2 = pinAction || {},
        id = _ref2.id,
        pinned = _ref2.pinned;

    if (!id) return;
    var newDragNodes = dragNodes;

    if (!pinned) {
      newDragNodes = dragNodes.filter(function (node) {
        return node.id !== id;
      });
    } else {
      var node = graph.findById(id);
      if (!node) return;
      var nodeModel = node.get('model');
      if (!nodeModel.layout) nodeModel.layout = {};
      nodeModel.layout.force = {
        mass: autoPin ? dragNodeMass : null
      };
      newDragNodes.push(nodeModel);
    }

    updateContext({
      dragNodes: newDragNodes
    });
  }, [pinAction]);
  return null;
};

DragNodeWithForce.defaultProps = {
  autoPin: false,
  dragNodeMass: 10000000000,
  pinAction: undefined
};
export default DragNodeWithForce;