"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processLayoutConfig = void 0;
var LAYOUT_CFG_KEY_MAP = {
  animation: 'animate',
  minDistanceThreshold: 'minMovement',
  maxIterations: 'maxIterations'
};

var processLayoutConfig = function processLayoutConfig(layoutCfg, graph) {
  if (!layoutCfg) return layoutCfg;
  var newLayoutCfg = {};
  Object.keys(layoutCfg).forEach(function (key) {
    var _a;

    if (key === 'preset' && ((_a = layoutCfg.preset) === null || _a === void 0 ? void 0 : _a.type)) {
      newLayoutCfg.preset = processLayoutConfig(layoutCfg.preset, graph);
      return;
    }

    var newKey = LAYOUT_CFG_KEY_MAP[key];

    if (newKey) {
      newLayoutCfg[newKey] = layoutCfg[key];
    } else {
      newLayoutCfg[key] = layoutCfg[key];
    }
  });

  if (layoutCfg.done) {
    // 兼容成 graphin 原先 done 的格式
    if (!layoutCfg.onLayoutEnd) {
      newLayoutCfg.onLayoutEnd = function (positions) {
        layoutCfg.done(graph, positions);
      };
    } else {
      newLayoutCfg.onLayoutEnd = function (positions) {
        layoutCfg.onLayoutEnd(graph, positions);
        layoutCfg.done(graph, positions);
      };
    }
  }

  if (newLayoutCfg.type === 'concentric') {
    var _newLayoutCfg$minNode = newLayoutCfg.minNodeSpacing,
        minNodeSpacing = _newLayoutCfg$minNode === void 0 ? 60 : _newLayoutCfg$minNode,
        _newLayoutCfg$prevent = newLayoutCfg.preventOverlap,
        preventOverlap = _newLayoutCfg$prevent === void 0 ? true : _newLayoutCfg$prevent,
        _newLayoutCfg$nodeSiz = newLayoutCfg.nodeSize,
        nodeSize = _newLayoutCfg$nodeSiz === void 0 ? 60 : _newLayoutCfg$nodeSiz;
    newLayoutCfg.minNodeSpacing = minNodeSpacing;
    newLayoutCfg.preventOverlap = preventOverlap;
    newLayoutCfg.nodeSize = nodeSize;
  }

  return newLayoutCfg;
};

exports.processLayoutConfig = processLayoutConfig;