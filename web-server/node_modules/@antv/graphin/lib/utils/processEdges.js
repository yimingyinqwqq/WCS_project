"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("@antv/util");

function isEven(number) {
  return number % 2 === 0;
}

function isOdd(number) {
  return !isEven(number);
}

var POLY_DEFAULT = 30;
var LOOP_DEFAULT = 10;
var LOOP_LABEL_POSITION_DEFAULT = 1;
/**
 *
 * @param edges 边的集合
 * @param {poly,loop} 设置多边和自环多边的distance
 */

var processEdges = function processEdges(edges) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    poly: POLY_DEFAULT,
    loop: LOOP_DEFAULT,
    loopLabelPosition: LOOP_LABEL_POSITION_DEFAULT
  },
      _ref$poly = _ref.poly,
      poly = _ref$poly === void 0 ? POLY_DEFAULT : _ref$poly,
      _ref$loop = _ref.loop,
      loop = _ref$loop === void 0 ? LOOP_DEFAULT : _ref$loop,
      _ref$loopLabelPositio = _ref.loopLabelPosition,
      loopLabelPosition = _ref$loopLabelPositio === void 0 ? LOOP_LABEL_POSITION_DEFAULT : _ref$loopLabelPositio;

  var edgesMap = {};
  edges.forEach(function (item, index) {
    var edge = Object.assign({}, item);
    var source = edge.source,
        target = edge.target;
    var edgeId = "".concat(source, "-").concat(target);
    edge.id = edge.id || "".concat(source, "-").concat(target, "-").concat(index);
    var revertEdgeId = "".concat(target, "-").concat(source);
    /** 存储edge */

    if (edgesMap[edgeId]) {
      edgesMap[edgeId].push(edge);
    } else if (edgesMap[revertEdgeId]) {
      edge.revert = true;
      edgesMap[revertEdgeId].push(edge);
    } else {
      edgesMap[edgeId] = [edge];
    }
  });
  var edgeGroups = Object.values(edgesMap);
  var newEdges = [];
  edgeGroups.forEach(function (edges) {
    if (edges.length > 1) {
      // 说明是多边的情况
      var isEvenCount = isEven(edges.length);
      edges.forEach(function (edge, i) {
        var _a;

        var source = edge.source,
            target = edge.target;
        var isLoop = source === target;
        var index = i; // edge.revert ? i + 1 : i;

        var distance;

        if (isEvenCount) {
          // 奇数
          var idx = Math.ceil((index + 1) / 2);
          distance = poly * idx;
        } else {
          // 偶数
          var calculateIdx = isOdd(index) ? index + 1 : index;

          var _idx = Math.ceil(calculateIdx / 2);

          distance = poly * _idx;
        }

        var resultDistance = isEven(index) ? distance : -distance; // 反向边需要revert

        if (edge.revert) {
          resultDistance = -resultDistance;
          delete edge.revert;
        }

        var keyshapeStyle;

        if (isLoop) {
          var _distance = index * loop;

          keyshapeStyle = {
            type: 'loop',
            loop: {
              distance: _distance
            }
          };

          if ((_a = edge.style) === null || _a === void 0 ? void 0 : _a.label) {
            var offsetX = 0;
            var offsetY = -(POLY_DEFAULT * loopLabelPosition + _distance * 2);
            edge.style.label.offset = [offsetX, offsetY];
          }
        } else {
          keyshapeStyle = {
            type: 'poly',
            poly: {
              distance: resultDistance
            }
          };
        }

        (0, _util.deepMix)(edge, {
          style: {
            keyshape: keyshapeStyle
          }
        });
        edge.isMultiple = true;
        newEdges.push(edge);
      });
    } else {
      newEdges.push(edges[0]);
    }
  });
  return newEdges;
};

var _default = processEdges;
exports.default = _default;